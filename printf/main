# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    main                                               :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: user42 <user42@student.42.fr>              +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2020/07/23 12:53:24 by user42            #+#    #+#              #
#    Updated: 2020/09/08 11:21:19 by user42           ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include <stdio.h>
#include <stdarg.h>
​
int main ()
{
	int nb, nb1, nb2, nb3, nb4, nb5;
/*	int x;
	//int y;
​
	// Cadena sin conversiones
	x = printf("original\n");
	// Bytes escritos
	printf("%d\n", x);
*/
	ft_printf("---------------------------------\n");
​
	// Conversiones de caracter (c)
	ft_printf("CONVERSIONES DE CARACTER (c)\n");
		// la precisión no influye
		// flags 0 es ignorado cuando hay un flag - (Warning)
		// flag 0 -> undefined behavior
	ft_printf("%-0*cFIN\n", 4, 'x'); //HECHO		// añade (width - 1(char)) espacios a la dcha (ignora el 0)
	ft_printf("%0*cFIN", 4, 'x');	//HECHO	// añade (width - 1(char)) 0s a la izq
	ft_printf("%-*cFIN", 4, 'x'); //HECHO		// añade (width - 1(char)) espacios a la dcha
	ft_printf("%-cFIN", 'x');	//HECHO		// no influye el - sin otro flag
	ft_printf("%4c", 'x');				// añade * espacios a la izq - 1(char)
	ft_printf("%10c", 'x');				// añade * espacios a la izq - 1(char)
​
	ft_printf("---------------------------------\n");
​
	// Conversiones de string (s)
	ft_printf("CONVERSIONES DE STRING (s)\n");
		// flags 0 es ignorado cuando hay un flag - (Warning)
		// flag 0 -> undefined behavior
	ft_printf("%0*.7sFIN\n", 10, "hola"); //HECHO		// La precisión escoge solo los x primeros caracteres y el * añade el width
										// sobrante a la izq en forma de 0s
	ft_printf("%-0*.2sFIN\n", 4, "hola"); //HECHO		// La precisión escoge solo los x primeros caracteres y el * añade el width
										// sobrante a la dcha en forma de espacios
	ft_printf("%-*sFIN\n", 6, "hola"); //HECHO		// añade (width - len(char *)) a la dcha
	ft_printf("%-*.2sFIN\n", 4, "hola"); //HECHO	// . coge los 2 primeros char y añade (width - len(char *)) espacios a dcha
	ft_printf("%*.2sFIN\n", 4, "hola");	// //HECHO . coge los 2 primeros char y añade (width - len(char *)) espacios a izq
	ft_printf("%*sFIN\n", 6, "hola"); //HECHO			// añade (width - len(char *)) espacios a la izq
	ft_printf("%-.2sFIN\n", "hola"); //HECHO
	ft_printf("%0.2sFIN\n", "hola"); //HECHO
​
		// Estos ejemplos de flags no influyen en la cadena
	ft_printf("X%-sFIN\n", "hola");
	ft_printf("X%0sFIN\n", "hola");
	ft_printf("X%-0sFIN\n", "hola"); // no mirar el printf no funcions con -0
	ft_printf("X%0.7sFIN\n", "hola"); //HECHO
	ft_printf("X%-.7sFIN\n", "hola"); //HECHO
​
	ft_printf("---------------------------------\n");
​
	// Conversiones de enteros (d)(i)
	ft_printf("CONVERSIONES DE ENTEROS (d)(i)\n");
		// flags 0 es ignorado cuando hay un flag - (Warning)
		// si el num dado como arg es de tipo double, añade tantos 0s como precisión o 1 si no está especificada
	ft_printf("%-0*.3dFIN\n", 4, 42);	//HECHO	// se cogen . int rellenando de 0s a la izq si fuera necesario completar
										// y el num sobrante rspcto al width se añade a la dcha en forma de espacio
	ft_printf("%0*.1dFIN\n", 4, -42);   //HECHO		// igual q el anterior pero el espacio se añade a la izq
	ft_printf("%-2.3dFIN\n", 42);			// se añade 0s a izq para completar la precisión y después se comprueba *
	ft_printf("%*dFIN\n", 4, -42);	//HECHO	// se añaden (width - len(int)) espacios a la izq, el - cuenta (len(-24) = 3)
	ft_printf("%-04.1dFIN\n", 42); //HECHO		// se añaden (width - len(int)) espacios a la dcha, la precisión es menor q
										// len(int) por lo que no se rellena con 0s
	ft_printf("%-*.5dFIN\n", 7, -42); //HECHO
	ft_printf("%*.5dFIN\n", 7, -42); //HECHO
	ft_printf("%*.7dFIN\n", 5, 42);	//HECHO
	ft_printf("%0*dFIN\n", 4, -42);	//HECHO
​
			// Estos ejemplos de flags, no influyen en la impresión de la cadena
	ft_printf("%-dFIN", 42); //HECHO
	ft_printf("%-0dFIN", 42); //HECHO
	ft_printf("%0dFIN", 42); //HECHO
	ft_printf("%*dFIN", 1, 42); //HECHO // width < nº cifras 
	ft_printf("%0*dFIN", 1, 42); //HECHO
	ft_printf("%.1dFIN", 42); //HECHO
	ft_printf("%-.1dFIN", 42); //HECHO
	ft_printf("%-*.2dFIN", 2, 42); //HECHO
​
	ft_printf("---------------------------------\n");
​
​
	// Conversiones de unsigned (u)
	nb = ft_printf("CONVERSIONES DE UNSIGNED (u)\n");
		// flags 0 es ignorado cuando hay un flag - (Warning)
		// argumentos negativos -> comportamiento indefinido
		// si el num dado como arg es de tipo double, añade tantos 0s como precisión o 1 si no está especificada
		// FUNCIONA COMO EL CASO DE ENTEROS
	nb1 = ft_printf("%0-*.3uFIN", 4, 42);		// El orden en presentar los flags 0 y - es indiferente
	nb2 = ft_printf("%0*.3uFIN", 4, -42);
	nb3 = ft_printf("%-4.3uFIN", 42);
	nb4 = ft_printf("%*uFIN", 4, 42);
	nb5 = ft_printf("%04.1uFIN", 42);
	ft_printf("%d %d %d %d %d %d\n", nb,  nb1, nb2, nb3, nb4, nb5);
​
	nb = ft_printf("---------------------------------\n");
​
	// Conversiones de hexadecimal sin signo (x)(X)
	nb1 = ft_printf("CONVERSIONES DE HEXADECIMAL SIN SIGNO (x)(X)\n");
		// ACTÚA COMO EL CASO NUMÉRICO PERO CONVIRTIENDO EL DECIMAL DADO A HEXADECIMAL
	nb2 = ft_printf("%-0*.3xFIN", 4, 42); //HECHO //02a FIN7
	nb3 = ft_printf("%0*.1XFIN", 4, 42); //HECHO //  2AFIN7
	nb4 = ft_printf("%-*.3xFIN", 4, 42); //HECHO //02a FIN7
	nb5 = ft_printf("%*XFIN", 4, 42); //HECHO //  2AFIN7
	ft_printf("%d %d %d %d %d %d\n", nb,  nb1, nb2, nb3, nb4, nb5);
	nb = ft_printf("%04.1XFIN", 42); //HECHO //  2AFIN7
​
	nb1 = ft_printf("---------------------------------\n");
	ft_printf("%d %d\n", nb, nb1);
​
​
	// Conversiones de direcciones de memoria (p)
	ft_printf("CONVERSIONES DE DIRECCIONES DE MEMORIA(p)\n");
		// La conversión es como el caso hexadecimal, salvo que la cadena se compone por el nº
		// de la dirección de memoria (sin tener en cuenta el 0x). Por tanto, cuando hay que añadir
		// sólo precisión se hace entre 0x y el nº; al igual que si sólo se añade width. En el caso
		// de añadir precisión y width, la precisión se añade de dicha forma y el width en forma de
		// espacios (antes del 0x cuando se añaden a la izq).
		// Todo esto influye solo en los casos en los que la precisión y/o el width son > len(nº)
​
		// Solo -* y *
	char *ptr = ft_strdup("prueba puntero");
​
	nb = ft_printf("%pFIN\n", ptr);
	printf("%d \n", nb);
	ft_printf("%-pFIN\n", ptr); //HECHO
	ft_printf("%0pFIN\n", ptr);	//HECHO
	ft_printf("%-0pFIN\n", ptr); //HECHO
​
	ft_printf("%*pFIN\n", 20, ptr); //HECHO
	ft_printf("%-*pFIN\n", 20, ptr); //HECHO
	ft_printf("%0*pFIN", 20, ptr);
	ft_printf("%-0*pFIN\n", 20, ptr); //HECHO
​
	ft_printf("%.3pFIN\n", ptr); //HECHO
	ft_printf("%-.3pFIN\n", ptr); //HECHO
	ft_printf("%0.3pFIN\n", ptr); //HECHO
	ft_printf("%-0.3pFIN\n", ptr); //HECHO
	// hasta aquí funciona incluso con undefined behavior
	ft_printf("%.17pFIN\n", ptr); //HECHO
	ft_printf("%-.17pFIN\n", ptr); //HECHO
	ft_printf("%0.17pFIN\n", ptr); //HECHO
	ft_printf("%-0.17pFIN\n", ptr); //HECHO
​
	ft_printf("%*.12pFIN\n", 20, ptr); //HECHO
	ft_printf("%-*.3pFIN\n", 20, ptr); //HECHO
	ft_printf("%0*.3pFIN\n", 20, ptr); //HECHO
	ft_printf("%-0*.3pFIN\n", 20, ptr); //HECHO
​
	// ARREGLAR ESTA PARTE (aunque no haría falta porque es undefined behavior)
	ft_printf("%*.17pFIN\n", 20, ptr);
	ft_printf("%-*.17pFIN\n", 20, ptr);
	ft_printf("%0*.17pFIN\n", 20, ptr);
	ft_printf("%-0*.17pFIN\n", 20, ptr);
​
	//printf("X%luX\n", &ptr);
	free(ptr);
​
	ft_printf("---------------------------------\n");
	// Carácter %
	ft_printf("CONVERSION CARACTER %%\n");
		// flags 0 es ignorado cuando hay un flag - (Warning)
	ft_printf("%-0*.3%FIN\n", 4); 			// añade un nº (*) - 1(tamaño char %) de espacios a la dcha
	ft_printf("%0*.3%\n", 4); 				// añade un nº (*) - 1(tamaño char %) de 0s a la izq
	ft_printf("%-04.3%FIN\n"); 			// añade un nº (*) - 1(tamaño char %) de espacios a la dcha
	ft_printf("%4.3%\n");					// añade un nº (*) - 1(tamaño char %) de espacios a la izq
	ft_printf("%10%\n");					// añade un nº (*) - 1(tamaño char %) de espacios a la izq
​
	return (0);


